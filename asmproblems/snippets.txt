; полезные фрагменты

; abs(x)
; для нахождения модуля можно использовать такие варианты:
        mov     rcx, rbx        ; сохраним текущее значение rbx
        neg     rbx
        cmovl   rbx, rcx        ; переслать данные из rcx->rbx, если предыдущее значение rbx меньше последнего (SF<>OF)
        mov     [len], rbx
        
        ; ещё способ: abs(x) = (x XOR y) - y, где y = x >> 31 (или 63, смотря какой размер числа)
        mov     rcx, rbx        ; y
        shr     rcx, 63
        mov     rax, rbx        ; <- x
        xor     rax, rcx        ; x XOR y
        sub     rax, rcx
        mov     [len], rax
;abs (xmm5):
        mov     rax, 0x7fffffffffffffff
        movq    xmm6, rax       ; маска для сброса знакового бита в xmm-регистре
        pand    xmm5, xmm6      ; знаковый бит -> 0

; обменять два xmm регистра
        pxor    xmm5, xmm6
        pxor    xmm6, xmm5
        pxor    xmm5, xmm6
; целое в xmm:
        mov     rax, 13
        cvtsi2sd xmm0, rax      ; xmm0 <- 13
; округление:
        cvttsd2si rax, xmm0     ; округление с усечением, MXCSR не используется
; расширить регистр:
        movsx   rax, word [N]
; сравнение вещественных
        одна из команд cmppd: cmplepd и т.д.
; поместить в стек xmm-регистр:
        sub     rsp, 16
        movq    qword [rsp], xmm6

        call    printf          ; что-то вызываем

        movq    xmm0, qword [rsp]
        add     rsp, 16
; сменить знак в xmm-регистре:
        mov     rax, 0x8000000000000000
        movq    xmm2, rax
        pxor    xmm0, xmm2      ; сменить старший бит на противоположный
