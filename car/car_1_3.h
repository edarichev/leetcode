#ifndef CAR_1_3_H
#define CAR_1_3_H

#include "macro.h" // ASSERT
#include <string>

/**
 * 1.3 Напишите метод, заменяющий все пробелы в строке символами '%20°. Можете
считать, что длина строки позволяет сохранить дополнительные символы,
а фактическая длина строки известна заранее. (Примечание: при реализации
метода на ]ауа для выполнения операции «на месте» используйте символьный
массив.)
 */
class CAR_1_3
{
public:
    // Это не нужно, но если в качестве дополнительного задания потребуется
    // увеличить длину строки
    static void resizeStr(std::string &str)
    {
        const std::string pattern = "%20";
        const size_t len = pattern.length();
        // для сокращения числа операций с памятью найдём количество пробелов
        // и 1 раз расширим строку
        size_t n = 0;
        for (auto &&c : str)
            if (c == ' ')
                n++;
        n = str.length() - n + n * len;
        // ставим пробелы - так по условию, если поставим без ' ', то и length, и size
        // дадут новую строку с нулями в конце
        str.resize(n, ' ');
    }

    static std::string replace1(std::string &str, size_t n)
    {
        // считаем, что места по условию достаточно
        // однако, длина буфера может быть какой угодно
        // надо уточнить:
        // если под "фактическая длина строки" понимается результирующая длина
        // то это просто - надо идти с конца, а если нет?
        // допустим, это так, тогда:
        int cur = str.length() - 1; // позиция, на которую перемещаем символ
        for (int i = n - 1; i != 0; i--) {
            if (str[i] == ' ') {
                str[cur--] = '0';
                str[cur--] = '2';
                str[cur--] = '%';
            } else {
                str[cur] = str[i];
                if (cur == i)
                    break; // нет смысла, пробелов больше нет или они уже не влезут
                cur--;
            }
            ASSERT(cur >= 0);
        }
        return str; // ту же строку для тестов
    }

    static void test()
    {
        // общий вариант - добавить места в строку
        std::string s1 = "Mr John Smith";
        size_t originalLen = s1.length();
        resizeStr(s1);
        // теперь места достаточно, но в конце пробелы - так по условию
        // теперь строка == "Mr John Smith      ";
        ASSERT(s1.length() == originalLen - 2 + 2*3); // минус 2 пробела + 2 по 3 "%20"

        // теперь непосредственно сама задача
        std::string s2 = "Mr John Smith    ";
        size_t n = 13;
        ASSERT(replace1(s2, n) == "Mr%20John%20Smith")
    }
};

#endif // CAR_1_3_H
